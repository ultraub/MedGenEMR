#!/usr/bin/env python3
"""
Import Synthea data using FHIR transaction bundles
This approach preserves all references and imports complete patient records
"""

import os
import json
import glob
import asyncio
import httpx
from typing import Dict, List, Any
from collections import defaultdict

# Configuration
FHIR_BASE_URL = "http://localhost:8000/fhir/R4"
SYNTHEA_OUTPUT_DIR = "synthea/output/fhir"

class SyntheaTransactionImporter:
    def __init__(self):
        self.imported_bundles = []
        self.failed_bundles = []
        self.resource_counts = defaultdict(int)
        
    def transform_bundle_to_transaction(self, bundle: Dict[str, Any]) -> Dict[str, Any]:
        """Transform a Synthea bundle into a transaction bundle"""
        
        # Create transaction bundle
        transaction_bundle = {
            "resourceType": "Bundle",
            "type": "transaction",
            "entry": []
        }
        
        # Process each entry
        for entry in bundle.get('entry', []):
            resource = entry.get('resource', {})
            if not resource:
                continue
                
            resource_type = resource.get('resourceType')
            resource_id = resource.get('id')
            
            if not resource_type or not resource_id:
                continue
            
            # Fix the resource structure
            fixed_resource = self.fix_resource_for_import(resource)
            
            # Create transaction entry
            transaction_entry = {
                "fullUrl": f"urn:uuid:{resource_id}",
                "resource": fixed_resource,
                "request": {
                    "method": "PUT",
                    "url": f"{resource_type}/{resource_id}"
                }
            }
            
            transaction_bundle['entry'].append(transaction_entry)
        
        return transaction_bundle
    
    def fix_resource_for_import(self, resource: Dict[str, Any]) -> Dict[str, Any]:
        """Fix common Synthea resource issues"""
        resource_type = resource.get('resourceType')
        fixed = json.loads(json.dumps(resource))  # Deep copy
        
        # Common fixes for all resources
        # Remove text.div if it's causing issues
        if 'text' in fixed and 'div' in fixed['text']:
            # Keep text but simplify div content
            fixed['text']['div'] = '<div xmlns="http://www.w3.org/1999/xhtml">Generated by Synthea</div>'
        
        # Resource-specific fixes
        if resource_type == 'Encounter':
            # Fix class - ensure it's an object not array
            if 'class' in fixed and isinstance(fixed['class'], dict):
                # Already correct
                pass
            
            # Fix period to only have start/end
            if 'period' in fixed:
                period = {}
                if 'start' in fixed['period']:
                    period['start'] = fixed['period']['start']
                if 'end' in fixed['period']:
                    period['end'] = fixed['period']['end']
                fixed['period'] = period
            
            # Fix participant
            if 'participant' in fixed:
                for participant in fixed['participant']:
                    if 'individual' in participant:
                        # Simplify to just reference
                        ref = participant['individual'].get('reference', '')
                        participant['individual'] = {'reference': ref}
            
            # Fix reasonCode
            if 'reasonCode' in fixed:
                for reason in fixed['reasonCode']:
                    if 'coding' in reason:
                        # Keep only standard fields
                        for coding in reason['coding']:
                            allowed = ['system', 'code', 'display', 'version']
                            for key in list(coding.keys()):
                                if key not in allowed:
                                    del coding[key]
        
        elif resource_type == 'Procedure':
            # Fix performedPeriod
            if 'performedPeriod' in fixed:
                period = {}
                if 'start' in fixed['performedPeriod']:
                    period['start'] = fixed['performedPeriod']['start']
                if 'end' in fixed['performedPeriod']:
                    period['end'] = fixed['performedPeriod']['end']
                fixed['performedPeriod'] = period
        
        elif resource_type == 'Claim':
            # Fix item.encounter
            if 'item' in fixed:
                for item in fixed['item']:
                    if 'encounter' in item and isinstance(item['encounter'], list):
                        # Keep only first encounter reference
                        if len(item['encounter']) > 0:
                            ref = item['encounter'][0].get('reference', '')
                            item['encounter'] = [{'reference': ref}]
        
        elif resource_type == 'ExplanationOfBenefit':
            # Similar to Claim
            if 'item' in fixed:
                for item in fixed['item']:
                    if 'encounter' in item and isinstance(item['encounter'], list):
                        if len(item['encounter']) > 0:
                            ref = item['encounter'][0].get('reference', '')
                            item['encounter'] = [{'reference': ref}]
        
        elif resource_type == 'MedicationRequest':
            # Fix dosageInstruction
            if 'dosageInstruction' in fixed:
                for dosage in fixed['dosageInstruction']:
                    if 'timing' in dosage and 'repeat' in dosage['timing']:
                        # Keep only valid repeat fields
                        repeat = dosage['timing']['repeat']
                        allowed = ['frequency', 'period', 'periodUnit', 'boundsPeriod',
                                 'count', 'countMax', 'duration', 'durationUnit',
                                 'timeOfDay', 'when', 'offset']
                        for key in list(repeat.keys()):
                            if key not in allowed:
                                del repeat[key]
        
        elif resource_type == 'DiagnosticReport':
            # Fix presentedForm
            if 'presentedForm' in fixed:
                for form in fixed['presentedForm']:
                    allowed = ['contentType', 'data', 'url', 'size', 'hash', 'title', 'creation']
                    for key in list(form.keys()):
                        if key not in allowed:
                            del form[key]
        
        elif resource_type == 'Observation':
            # Fix component valueQuantity
            if 'component' in fixed:
                for component in fixed['component']:
                    if 'valueQuantity' in component:
                        quantity = component['valueQuantity']
                        allowed = ['value', 'unit', 'system', 'code', 'comparator']
                        for key in list(quantity.keys()):
                            if key not in allowed:
                                del quantity[key]
        
        return fixed
    
    async def import_bundle(self, client: httpx.AsyncClient, bundle_path: str) -> bool:
        """Import a complete bundle as a transaction"""
        print(f"\nüì¶ Processing bundle: {os.path.basename(bundle_path)}")
        
        try:
            with open(bundle_path, 'r') as f:
                bundle = json.load(f)
            
            if bundle.get('resourceType') != 'Bundle':
                print(f"   ‚ö†Ô∏è  Not a Bundle resource")
                return False
            
            # Count resources by type
            resource_types = defaultdict(int)
            for entry in bundle.get('entry', []):
                if 'resource' in entry:
                    resource_type = entry['resource'].get('resourceType')
                    if resource_type:
                        resource_types[resource_type] += 1
            
            print(f"   Found {sum(resource_types.values())} resources:")
            for rtype, count in sorted(resource_types.items()):
                print(f"     - {rtype}: {count}")
            
            # Transform to transaction bundle
            transaction_bundle = self.transform_bundle_to_transaction(bundle)
            
            if not transaction_bundle['entry']:
                print(f"   ‚ö†Ô∏è  No valid entries to import")
                return False
            
            print(f"   üì§ Submitting transaction bundle with {len(transaction_bundle['entry'])} entries...")
            
            # Submit transaction
            response = await client.post(
                FHIR_BASE_URL,
                json=transaction_bundle,
                timeout=300.0  # 5 minute timeout for large bundles
            )
            
            if response.status_code in [200, 201]:
                # Count successful imports
                response_bundle = response.json()
                successful = 0
                failed = 0
                
                for entry in response_bundle.get('entry', []):
                    if entry.get('response', {}).get('status', '').startswith('2'):
                        successful += 1
                    else:
                        failed += 1
                
                print(f"   ‚úÖ Transaction complete: {successful} succeeded, {failed} failed")
                
                # Update counts
                for rtype, count in resource_types.items():
                    self.resource_counts[rtype] += count
                
                self.imported_bundles.append(os.path.basename(bundle_path))
                return True
                
            else:
                print(f"   ‚ùå Transaction failed with status {response.status_code}")
                try:
                    error_data = response.json()
                    if 'issue' in error_data:
                        print("   Error details:")
                        for issue in error_data.get('issue', [])[:3]:  # Show first 3 issues
                            severity = issue.get('severity', 'unknown')
                            details = issue.get('details', {}).get('text', 'No details')
                            print(f"     - {severity}: {details[:150]}...")
                except:
                    print(f"   Response: {response.text[:500]}...")
                
                self.failed_bundles.append(os.path.basename(bundle_path))
                return False
                
        except Exception as e:
            print(f"   ‚ùå Exception: {str(e)}")
            self.failed_bundles.append(os.path.basename(bundle_path))
            return False
    
    def print_summary(self):
        """Print import summary"""
        print("\n" + "="*60)
        print("üìä Synthea Transaction Import Summary")
        print("="*60)
        
        print(f"\nBundles processed: {len(self.imported_bundles) + len(self.failed_bundles)}")
        print(f"  ‚úÖ Successful: {len(self.imported_bundles)}")
        print(f"  ‚ùå Failed: {len(self.failed_bundles)}")
        
        if self.resource_counts:
            print(f"\nüìã Resources imported by type:")
            total = 0
            for rtype, count in sorted(self.resource_counts.items()):
                print(f"   {rtype}: {count}")
                total += count
            print(f"\n   Total resources: {total}")
        
        if self.failed_bundles:
            print(f"\n‚ùå Failed bundles:")
            for bundle in self.failed_bundles:
                print(f"   - {bundle}")

async def main():
    """Main import function"""
    print("üè• Synthea FHIR Transaction Import")
    print("="*60)
    
    # Check server
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get(f"{FHIR_BASE_URL}/metadata", timeout=10.0)
            if response.status_code != 200:
                print(f"‚ùå FHIR server not responding correctly")
                return False
            print("‚úÖ FHIR server is running")
        except Exception as e:
            print(f"‚ùå Cannot connect to FHIR server at {FHIR_BASE_URL}")
            return False
    
    # Find bundles
    if not os.path.exists(SYNTHEA_OUTPUT_DIR):
        print(f"‚ùå Synthea output directory not found: {SYNTHEA_OUTPUT_DIR}")
        return False
    
    # Import infrastructure first
    print("\nüìã Importing infrastructure resources...")
    infra_files = glob.glob(os.path.join(SYNTHEA_OUTPUT_DIR, "*Information*.json"))
    
    importer = SyntheaTransactionImporter()
    
    async with httpx.AsyncClient() as client:
        # Import infrastructure
        for infra_file in sorted(infra_files):
            await importer.import_bundle(client, infra_file)
        
        # Import patient bundles
        patient_files = glob.glob(os.path.join(SYNTHEA_OUTPUT_DIR, "*.json"))
        patient_bundles = [f for f in patient_files if 
                         not f.endswith('hospitalInformation.json') and 
                         not f.endswith('practitionerInformation.json')]
        
        print(f"\nüìÅ Found {len(patient_bundles)} patient bundles to import")
        
        for bundle_path in sorted(patient_bundles):
            await importer.import_bundle(client, bundle_path)
    
    # Print summary
    importer.print_summary()
    
    print(f"\nüåê Test your complete EMR data at: http://localhost:3000")
    return len(importer.imported_bundles) > 0

if __name__ == "__main__":
    success = asyncio.run(main())
    if success:
        print("\nüéâ Synthea import completed successfully!")
    else:
        print("\n‚ùå Synthea import failed")
        exit(1)